name: Release - Semantic Versioning & Artifacts

on:
  push:
    branches: [ main ]
    paths:
      - '**/*.tf'
      - '**/*.md'
      - '.github/workflows/release.yml'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
      prerelease:
        description: 'Create a prerelease'
        required: false
        default: false
        type: boolean

env:
  TERRAFORM_VERSION: "1.9.8"

jobs:
  # Analyze changes to determine version bump
  analyze-changes:
    name: Analyze Changes
    runs-on: ubuntu-latest
    outputs:
      version_bump: ${{ steps.conventional.outputs.version }}
      new_release_published: ${{ steps.conventional.outputs.new_release_published }}
      new_release_version: ${{ steps.conventional.outputs.new_release_version }}
      new_release_notes: ${{ steps.conventional.outputs.new_release_notes }}
      modules_changed: ${{ steps.changes.outputs.modules }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze conventional commits
        id: conventional
        uses: cycjimmy/semantic-release-action@v4
        with:
          semantic_version: 24.5.0
          extra_plugins: |
            @semantic-release/changelog@6.0.3
            @semantic-release/git@10.0.1
            conventional-changelog-conventionalcommits@8.0.0
          dry_run: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect changed modules
        id: changes
        run: |
          # Get list of changed files since last release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            echo "Comparing changes since $LAST_TAG"
            CHANGED_FILES=$(git diff --name-only $LAST_TAG...HEAD)
          else
            echo "No previous tags found, analyzing all files"
            CHANGED_FILES=$(find . -name "*.tf" -o -name "*.md" | grep -v "\.terraform" | sed 's|^\./||')
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Extract unique module directories
          CHANGED_MODULES=$(echo "$CHANGED_FILES" | grep -E '\.(tf|md)$' | cut -d'/' -f1 | sort -u | grep -E '^azure-' || true)
          
          if [ -n "$CHANGED_MODULES" ]; then
            echo "Changed modules:"
            echo "$CHANGED_MODULES"
            MODULES_JSON=$(echo "$CHANGED_MODULES" | jq -R -s -c 'split("\n")[:-1]')
            echo "modules=$MODULES_JSON" >> $GITHUB_OUTPUT
          else
            echo "modules=[]" >> $GITHUB_OUTPUT
          fi

      - name: Override version bump if manual
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.release_type != 'auto'
        run: |
          echo "Manual release triggered with type: ${{ github.event.inputs.release_type }}"

  # Validate modules before release
  pre-release-validation:
    name: Pre-Release Validation
    runs-on: ubuntu-latest
    needs: analyze-changes
    if: needs.analyze-changes.outputs.new_release_published == 'true' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        module: ${{ fromJson(needs.analyze-changes.outputs.modules_changed) }}
      fail-fast: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Validate Module
        run: |
          cd ${{ matrix.module }}
          terraform init -backend=false
          terraform validate

      - name: Validate Examples
        run: |
          MODULE_DIR="${{ matrix.module }}"
          if [ -d "$MODULE_DIR/examples" ]; then
            for example_dir in $MODULE_DIR/examples/*/; do
              if [ -d "$example_dir" ] && [ -f "$example_dir/main.tf" ]; then
                echo "Validating example: $example_dir"
                cd "$example_dir"
                terraform init -backend=false
                terraform validate
                cd - > /dev/null
              fi
            done
          fi

  # Generate module documentation
  generate-docs:
    name: Generate Documentation
    runs-on: ubuntu-latest
    needs: [analyze-changes, pre-release-validation]
    if: needs.analyze-changes.outputs.new_release_published == 'true' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        module: ${{ fromJson(needs.analyze-changes.outputs.modules_changed) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate Terraform docs
        uses: terraform-docs/gh-actions@v1.2.0
        with:
          working-dir: ${{ matrix.module }}
          output-file: README.md
          output-method: inject
          git-push: false
          config-file: |
            formatter: "markdown table"
            header-from: main.tf
            footer-from: ""
            recursive:
              enabled: false
            sections:
              hide: []
              show: ["header", "requirements", "providers", "modules", "resources", "inputs", "outputs"]
            content: |-
              {{ .Header }}
              
              ## Requirements
              
              {{ .Requirements }}
              
              ## Providers
              
              {{ .Providers }}
              
              {{ if .Modules -}}
              ## Modules
              
              {{ .Modules }}
              {{ end -}}
              
              ## Resources
              
              {{ .Resources }}
              
              ## Inputs
              
              {{ .Inputs }}
              
              ## Outputs
              
              {{ .Outputs }}

      - name: Upload generated docs
        uses: actions/upload-artifact@v4
        with:
          name: docs-${{ matrix.module }}
          path: ${{ matrix.module }}/README.md

  # Create release
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [analyze-changes, pre-release-validation, generate-docs]
    if: needs.analyze-changes.outputs.new_release_published == 'true' || github.event_name == 'workflow_dispatch'
    outputs:
      version: ${{ steps.release.outputs.new_release_version }}
      published: ${{ steps.release.outputs.new_release_published }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download all documentation artifacts
        uses: actions/download-artifact@v5
        with:
          pattern: docs-*
          merge-multiple: true

      - name: Commit updated documentation
        if: needs.analyze-changes.outputs.modules_changed != '[]'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Check if there are any changes to commit
          if git diff --quiet; then
            echo "No documentation changes to commit"
          else
            git add -A
            git commit -m "docs: update module documentation [skip ci]" || echo "No changes to commit"
            git push
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create semantic release config
        run: |
          cat > .releaserc.json << 'EOF'
          {
            "branches": ["main"],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    {"type": "feat", "release": "minor"},
                    {"type": "fix", "release": "patch"},
                    {"type": "docs", "release": "patch"},
                    {"type": "style", "release": false},
                    {"type": "refactor", "release": "patch"},
                    {"type": "perf", "release": "patch"},
                    {"type": "test", "release": false},
                    {"type": "build", "release": "patch"},
                    {"type": "ci", "release": false},
                    {"type": "chore", "release": false},
                    {"type": "revert", "release": "patch"},
                    {"scope": "no-release", "release": false},
                    {"breaking": true, "release": "major"}
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits",
                  "presetConfig": {
                    "types": [
                      {"type": "feat", "section": "✨ Features"},
                      {"type": "fix", "section": "🐛 Bug Fixes"},
                      {"type": "docs", "section": "📚 Documentation"},
                      {"type": "refactor", "section": "♻️ Code Refactoring"},
                      {"type": "perf", "section": "⚡ Performance Improvements"},
                      {"type": "build", "section": "🔧 Build System"},
                      {"type": "revert", "section": "⏪ Reverts"}
                    ]
                  }
                }
              ],
              [
                "@semantic-release/changelog",
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/github",
                {
                  "assets": []
                }
              ],
              [
                "@semantic-release/git",
                {
                  "assets": ["CHANGELOG.md"],
                  "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
                }
              ]
            ]
          }
          EOF

      - name: Install semantic-release
        run: |
          npm install -g semantic-release@24.5.0
          npm install -g @semantic-release/changelog@6.0.3
          npm install -g @semantic-release/git@10.0.1
          npm install -g conventional-changelog-conventionalcommits@8.0.0

      - name: Create Release (Automatic)
        id: release
        if: github.event_name != 'workflow_dispatch'
        run: |
          semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Release (Manual)
        id: manual_release
        if: github.event_name == 'workflow_dispatch'
        run: |
          # Get current version
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
          echo "Current version: $CURRENT_VERSION"
          
          # Calculate new version based on input
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          case "${{ github.event.inputs.release_type }}" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              ;;
            *)
              echo "Unknown release type: ${{ github.event.inputs.release_type }}"
              exit 1
              ;;
          esac
          
          if [ "${{ github.event.inputs.prerelease }}" == "true" ]; then
            NEW_VERSION="$NEW_VERSION-rc.$(date +%Y%m%d%H%M%S)"
          fi
          
          echo "New version: $NEW_VERSION"
          
          # Create release notes
          RELEASE_NOTES="## 🚀 Release v$NEW_VERSION
          
          This is a manual release created via workflow dispatch.
          
          ### Changed Modules
          $(echo '${{ needs.analyze-changes.outputs.modules_changed }}' | jq -r '.[]' | sed 's/^/- /' || echo "- No specific modules changed")
          
          ### Manual Release Information
          - **Release Type**: ${{ github.event.inputs.release_type }}
          - **Prerelease**: ${{ github.event.inputs.prerelease }}
          - **Triggered by**: @${{ github.actor }}
          - **Commit**: ${{ github.sha }}
          "
          
          # Create git tag
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
          git push origin "v$NEW_VERSION"
          
          # Create GitHub release
          gh release create "v$NEW_VERSION" \
            --title "Release v$NEW_VERSION" \
            --notes "$RELEASE_NOTES" \
            ${{ github.event.inputs.prerelease == 'true' && '--prerelease' || '' }}
          
          echo "new_release_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_release_published=true" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Package modules as artifacts
  package-artifacts:
    name: Package Release Artifacts
    runs-on: ubuntu-latest
    needs: [analyze-changes, create-release]
    if: (needs.create-release.outputs.published == 'true' || steps.manual_release.outputs.new_release_published == 'true')
    strategy:
      matrix:
        module: ${{ fromJson(needs.analyze-changes.outputs.modules_changed) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Package Module
        run: |
          MODULE_NAME="${{ matrix.module }}"
          VERSION="${{ needs.create-release.outputs.version || steps.manual_release.outputs.new_release_version }}"
          
          # Create package directory
          PACKAGE_DIR="terraform-azure-${MODULE_NAME#azure-}-${VERSION}"
          mkdir -p "$PACKAGE_DIR"
          
          # Copy module files
          cp -r "$MODULE_NAME"/* "$PACKAGE_DIR"/
          
          # Remove any .terraform directories or state files
          find "$PACKAGE_DIR" -name ".terraform" -type d -exec rm -rf {} + 2>/dev/null || true
          find "$PACKAGE_DIR" -name "*.tfstate*" -type f -delete 2>/dev/null || true
          find "$PACKAGE_DIR" -name ".terraform.lock.hcl" -type f -delete 2>/dev/null || true
          
          # Create module metadata
          cat > "$PACKAGE_DIR/MODULE_INFO.json" << EOF
          {
            "name": "$MODULE_NAME",
            "version": "$VERSION",
            "description": "Azure Terraform module for ${MODULE_NAME#azure-}",
            "source": "${{ github.server_url }}/${{ github.repository }}",
            "tag": "v$VERSION",
            "release_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "terraform_version": "${{ env.TERRAFORM_VERSION }}",
            "checksum": "$(find "$PACKAGE_DIR" -type f -name "*.tf" -exec sha256sum {} + | sha256sum | cut -d' ' -f1)"
          }
          EOF
          
          # Create tarball
          tar -czf "${PACKAGE_DIR}.tar.gz" "$PACKAGE_DIR"
          
          # Create zip
          zip -r "${PACKAGE_DIR}.zip" "$PACKAGE_DIR"
          
          echo "Created packages:"
          ls -la "${PACKAGE_DIR}".{tar.gz,zip}

      - name: Upload to Release
        run: |
          MODULE_NAME="${{ matrix.module }}"
          VERSION="${{ needs.create-release.outputs.version || steps.manual_release.outputs.new_release_version }}"
          PACKAGE_DIR="terraform-azure-${MODULE_NAME#azure-}-${VERSION}"
          
          gh release upload "v$VERSION" \
            "${PACKAGE_DIR}.tar.gz" \
            "${PACKAGE_DIR}.zip" \
            --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.module }}-packages
          path: |
            terraform-azure-*.tar.gz
            terraform-azure-*.zip

  # Update registry or notification
  post-release:
    name: Post-Release Actions
    runs-on: ubuntu-latest
    needs: [create-release, package-artifacts]
    if: needs.create-release.outputs.published == 'true' || steps.manual_release.outputs.new_release_published == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate Release Summary
        run: |
          VERSION="${{ needs.create-release.outputs.version || steps.manual_release.outputs.new_release_version }}"
          
          echo "## 🎉 Release v$VERSION Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 Release Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: v$VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: [v$VERSION](${{ github.server_url }}/${{ github.repository }}/releases/tag/v$VERSION)" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: [${{ github.sha }}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Date**: $(date -u +%Y-%m-%d\ %H:%M:%S\ UTC)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ '${{ needs.analyze-changes.outputs.modules_changed }}' != '[]' ]; then
            echo "### 📋 Updated Modules" >> $GITHUB_STEP_SUMMARY
            echo '${{ needs.analyze-changes.outputs.modules_changed }}' | jq -r '.[]' | sed 's/^/- `/' | sed 's/$/`/' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### 🔗 Quick Links" >> $GITHUB_STEP_SUMMARY
          echo "- [📋 Release Notes](${{ github.server_url }}/${{ github.repository }}/releases/tag/v$VERSION)" >> $GITHUB_STEP_SUMMARY
          echo "- [📚 Repository](${{ github.server_url }}/${{ github.repository }})" >> $GITHUB_STEP_SUMMARY
          echo "- [📥 Download Assets](${{ github.server_url }}/${{ github.repository }}/releases/tag/v$VERSION)" >> $GITHUB_STEP_SUMMARY

      - name: Notify Teams (Optional)
        run: |
          echo "Release v${{ needs.create-release.outputs.version || steps.manual_release.outputs.new_release_version }} has been published!"
          echo "You can add webhook notifications here to notify your team via Slack, Teams, etc."
          
          # Example for future webhook integration:
          # curl -X POST "$WEBHOOK_URL" \
          #   -H "Content-Type: application/json" \
          #   -d "{\"text\": \"🚀 New release v$VERSION of terraform-azure-modules is available!\"}"
